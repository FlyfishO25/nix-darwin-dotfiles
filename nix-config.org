#+title: Nix-Darwin-Config +
#+subtitle: Nix-powered declarative macOS configuration
#+author: Shaurya Singh
#+options: broken-links:t
#+latex_header: \let\textls\relax
#+latex_class: chameleon
#+startup: preview
#+startup: fold
#+options: broken-links:t
#+options: toc:5

#+begin_export HTML
<a href="https://github.com/shaunsingh/nix-darwin-dotfiles/"
   style="font-family: 'Open Sans'; background-image: none; color: inherit;
   text-decoration: none; position: relative; top: clamp(-26px, calc(1280px - 100vw), 0px); opacity: 0.7;">
  <img src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg"
       class="invertible" alt="GitHub Octicon"
       style="height: 1em; position: relative; top: 0.1em;">
  View on GitHub</a>
#+end_export

* Introduction
Once upon a time I was a wee little lad playing around with vim. After that, my "ricing" addiction grew, and soon it turned into a dotfiles repo. Since I moved machines often, I wanted a simple way to install all dependencies for my system. What started off as a simple =install.sh= script turned into a dotfiles repo managed via [[https://yadm.io][YADM]]. However this raised a few issues:
1. It was slow and clunky. Apps like [[https://discord.com][Discord]] and [[https://www.mozilla.org/en-US/firefox/new/][Firefox]] started to clutter up my =~/.config= directory, and my =.gitignore= kept growing. With nix, my config is stored in one folder, and symlinked into place
2. Applications were all configured using different languages. With home-manager for the most part I can stick to using nix,
3. Building apps was a pain, and switching laptops was getting annoying.

** Note On Installing
If you like the look of this, that's marvellous, and I'm really happy that I've
made something which you may find interesting, however:
#+begin_warning
This config is /insidious/. Copying the whole thing blindly can easily lead to
undesired effects. I recommend copying chunks instead.
#+end_warning

Oh, did I mention that I started this config when I didn't know any =nix= or =lisp=, and
this whole thing is a hack job? If you can suggest any improvements, please do
so, no matter how much criticism you include I'll appreciate it :)

** Why Nix?
Nix consists of two parts: a package manager and a language. The language is a rather simple lazy (almost) pure functional language with dynamic typing that specializes in building packages. The package manager, on the other hand, is interesting and pretty unique. It all starts with one idea.

Nix stems from the idea that FHS is fundamentally incompatible with reproducibility. Every time you see a path like =/bin/python= or =/lib/libudev.so=, there are a lot of things that you don’t know about the file that’s located there.

What’s the version of the package it came from?
What are the libraries it uses?
What configure flags were enabled during the build?
Answers to these questions can (and most likely will) change the behaviour of an application that uses those files. There are ways to get around this in FHS – for example, link directly to =/lib/libudev.so.1.6.3= or use =/bin/python3.7= in your shebang. However, there are still a lot of unknowns.

This means that if we want to get any reproducibility and consistency, FHS does not work since there is no way to infer a lot of properties of a given file.

One solution is tools like Docker, Snap, and Flatpak that create isolated FHS environments containing fixed versions of all the dependencies of a given application, and distribute those environments. However, this solution has a host of problems.

What if we want to apply different configure flags to our application or change one of the dependencies? There is no guarantee that you would be able to get the build artifact from build instructions, since putting all the build artifacts in an isolated container guarantees consistency, not reproducibility, because during build-time, tools from host’s FHS are often used, and besides the dependencies that come from other isolated environments might change.

For example, two people using the same docker image will always get the same results, but two people building the same Dockerfile can (and often do) end up with two different images.

** Drawbacks of Nix (on macOS)
The biggest issue with Nix on darwin is that NixOS (and Nix on linux) takes priority. This means:
1. Apps aren't guaranteed to build on macOS
2. External dependencies and overlays (e.g. =home-manager=) aren't guaranteed to work perfectly on darwin
3. GUI application support is almost nonexistent

MacOS is also quite locked down compared to linux, which limits the customization you can do. You also need =nix-darwin= to manage flake configurations and macOS settings. Be prepared for nix (and other package managers) to break in a future macOS update.
On top of this, =aarch64-darwin= is a Tier 4 platform, if packages that are failing the test aren't critical, they get merged. You will run into packages that don't run on m1 at all, and will likely have to PR or open an issue to get them fixed.
Lastly, remember that =aarch64-darwin= is fairly new. Especially if you use the stable channel, expect to have to build the majority of packages from source. Even if you use the unstable/master channels, you will likely end up building some packages from source

** Nix vs Homebrew, Pkgsrc, and Macports
The main package managers on macOS are:
1. [[https://github.com/NixOS/nix][Nix]]
2. [[https://www.macports.org][Macports]]
3. [[https://pkgsrc.joyent.com/install-on-osx/ ][Pkgsrc]]
4. [[https://brew.sh][Homebrew]]

#+plot: transpose:yes type:radar min:0 max:5 ticks:5 file:"./extra/assets/pm-comparison.jpeg"
| Pkg Manager    | Pkg Availability | Pkg Freshness | Ease of Use | Features | Performance |
|----------------+------------------+---------------+-------------+----------+-------------|
| Nix (Unstable) |                5 |             5 |         2.5 |      4.5 |           4 |
| Macports       |              3.5 |             3 |           3 |        3 |           4 |
| Pkgsrc         |                2 |             2 |           2 |        4 |           5 |
| Homebrew       |              3.5 |           4.5 |         4.5 |        2 |           2 |

#+attr_html: :alt Radar chart comparing my thoughts on a few macOS package managers
[[file:./extra/assets/pm-comparison.jpeg]]

Package management on macOS has a somewhat complex history, mostly owing to the fact that unlike most Linux distributions, macOS does not ship with a default package manager out of the box. It’s not surprising that one of the first projects to solve the problem of package management, Fink, was created very early, with its initial releases predating that of Mac OS X 10.0 by several months. Using Debian’s =dpkg= and =apt= as its backend, Fink is still actively maintained, though I haven’t looked at it very closely.

MacPorts, on the other hand, was released in 2002 as part of OpenDarwin, while Homebrew was released seven years later as a “solution” to many of the shortcomings that the author saw in MacPorts. Pkgsrc is an older package manager for UNIX-like systems, and supports several BSD's, as well as Linux and MacOS.  Nix is a cross-platform package manager that utilizes a purely functional deployment model where software is installed into unique directories generated through cryptographic hashes. It is also the name of the tool's programming language. A package's hash takes into account the dependencies. This package management model advertises more reliable, reproducible, and portable packages.

Homebrew makes several questionable design decisions, but one of these deserves its own section: the choice to explicitly eschew root (in fact, it will refuse to work at all if run this way). This fundamentally is a very bad idea: package managers that install software for all users of your computer, as Homebrew does by default, should always require elevated privileges to function correctly. This decision has important consequences for both security and usability, especially with the advent of System Integrity Protection in OS X El Capitan.

For quite a while, Homebrew essentially considered itself the owner of =/usr/local= (both metaphorically and literally, as it would change the permissions of the directory), to the point where it would do things like plop its README down directly into this folder. After rootless was introduced, it moved most of its files to subdirectories; however, to maintain the charade of “sudo-less” installation, Homebrew will still trash the permissions of folders inside =/usr/local=. Homebrew’s troubleshooting guide lists these out, because reinstalling macOS sets the permissions back to what they’re supposed to be and breaks Homebrew in the process.

#+begin_quote
If commands fail with permissions errors, check the permissions of /usr/local’s subdirectories. If you’re unsure what to do, you can run cd /usr/local && sudo chown -R $(whoami) bin etc include lib sbin share var opt Cellar Caskroom Frameworks.
#+end_quote

MacPorts, on the other hand, swings so far in the other direction that it’s actually borderline inconvenient to use in some sense. Philosophically, MacPorts has a very different perspective of how it should work: it tries to prevent conflicts with the system as much as possible. To achieve this, it sets up a hierarchy under =/opt= (which is the annoying bit, because this directory is not on =$PATH= by default, nor is picked up by compilers without some prodding).

Of course, this design means that there is a single shared installation is among users, so running =port= requires elevated privileges whenever performing an operation that affects all users (which, admittedly, is most of the time). MacPorts is smart about this, though: it will shed permissions and run as the =macports= user whenever possible.

In line with their stated philosophy to prevent conflicts with macOS, MacPorts will set up its own tools in isolation from those provided by the system (in fact, builds run in “sandboxes” under the =macports= user, where attempts to access files outside of the build directory–which includes system tools–are intercepted and blocked). This means MacPorts needs to install some “duplicate” tools (whereas Homebrew will try to use the ones that come with your system where possible), the downside of which is that there is an one-time “up-front” cost as it installs base packages. The upside is that this approach is significantly more contained, which makes it easier to manage and more likely to continue working as macOS changes under it.

Finally, MacPorts just seems to have a lot of thought put into it with regards to certain aspects: for example, the MacPorts Registry database is backed by SQLite by default, which makes easily introspectable in case something goes wrong. Another useful feature is built-in “livechecks” for most ports, which codify upstream version checks and make it easy to see when MacPorts’s package index need to be updated.

I won't delve too much into why I choose nix in the end (as I've covered it before), but I feel like nix takes the best of both worlds and more. You have the ease of use that homebrew provides, the sandboxing and though that was put into MacPorts, while having excellent sandboxing and the seperate =nixbld= user.

* Installing and notes
*NOTE: These are available as an executable script [[file:./extra/install.sh]]*

Install Nix. I have it setup for multi-user, but you can remove the =--daemon= if you want a single user install
#+begin_src bash :comments none :tangle "./extra/install.sh" :shebang "#!/bin/bash"
    sh <(curl -L https://nixos.org/nix/install) --daemon
#+end_src
Launch an ephemeral shell with git, nixUnstable, and Emacs
#+begin_src bash :comments none :tangle "./extra/install.sh" :shebang "#!/bin/bash"
    nix-shell -p nixUnstable git emacs
#+end_src
Tangle the =.org= files (not needed, but recommend in case I forgot to update tangled files)
#+begin_src bash :comments none :tangle "./extra/install.sh" :shebang "#!/bin/bash"
    git clone --depth 1 https://github.com/shaunsingh/nix-darwin-dotfiles.git ~/nix-darwin-dotfiles/ && cd nix-darwin-dotfiles
    emacs --batch --eval "(progn (require 'org) (setq org-confirm-babel-evaluate nil) (org-babel-tangle-file \"~/nix-darwin-dotfiles/nix-config.org\"))"
    emacs --batch --eval "(progn (require 'org) (setq org-confirm-babel-evaluate nil) (org-babel-tangle-file \"~/nix-darwin-dotfiles/configs/doom/config.org\"))"
#+end_src
(if emacs asks you for comment syntax, put `# ` for everything)
Build, and switch to the dotfiles
#+begin_src bash :comments none :tangle "./extra/install.sh" :shebang "#!/bin/bash"
    nix build ~/nix-darwin-dotfiles\#darwinConfigurations.shaunsingh-laptop.system --extra-experimental-features nix-command --extra-experimental-features flakes
    ./result/sw/bin/darwin-rebuild switch --flake .#shaunsingh-laptop
#+end_src
(note, =--extra-experimental-features= is only needed the first time around. After that the configuration will edit =/etc/nix/nix.conf= to enable flakes and nix-command by default)
Symlinking with nix (and managing doom with =nix-doom-emacs=) is very finicky, so for now we need to manually symlink them
#+begin_src bash :comments none :tangle "./extra/install.sh" :shebang "#!/bin/bash"
    ln -s ~/nix-darwin-dotfiles/configs/doom/ ~/.config/doom
#+end_src
Install doom emacs
#+begin_src bash :comments none :tangle "./extra/install.sh" :shebang "#!/bin/bash"
    git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.config/emacs
    ~/.config/emacs/bin/doom install
#+end_src

** Using Nix unstable OOTB
If you want to use nix unstable out of of the box then you can use the following script
#+begin_src bash :comments none :tangle "./extra/nix-install.sh" :shebang "#!/bin/bash"
RELEASE="nix-2.5pre20211019_4a2b7cc"
URL="https://github.com/numtide/nix-unstable-installer/releases/download/$RELEASE/install"

# install using workaround for darwin systems
if [[ $(uname -s) = "Darwin" ]]; then
    FLAG="--darwin-use-unencrypted-nix-store-volume"
fi

[[ ! -z "$1" ]] && URL="$1"

if command -v nix > /dev/null; then
    echo "nix is already installed on this system."
else
    bash <(curl -L $URL) --daemon $FLAG
fi
#+end_src

** Additional Configuration
*** Emacs
If you want to use [[https://github.com/emacs-ng/emacs-ng][Emacs-NG]], use the following build options
#+begin_src bash
  git clone --depth 1 https://github.com/emacs-ng/emacs-ng.git
  cd emacs-ng
  ./autogen.sh
  ./configure CFLAGS="-Wl,-rpath,shared,--disable-new-dtags -g -O3 -mtune=native -march=native -fomit-frame-pointer" \
              --prefix=/usr/local/ \
              --with-json --with-modules --with-compress-install \
              --with-threads --with-included-regex --with-zlib --with-libsystemd \
              --with-rsvg --with-native-compilation --with-webrender --without-javascript \
              --without-sound --without-imagemagick --without-makeinfo --without-gpm --without-dbus \
              --without-pop --without-toolkit-scroll-bars --without-mailutils --without-gsettings \
              --with-all
  make -j$(($(nproc) * 2)) NATIVE_FULL_AOT=1
  make install-strip
#+end_src

If you want to update the doom configuration, you can run
#+begin_src bash
doom upgrade
#+end_src

If you modify your shell configuration, please do run =doom env= to regenerate env vars

**** Mu4e and Gmail
Email will have a few issues, since its hardcoded to my account. Replace instances of my name and email in =~/.doom.d/config.org=
Indexed mail will go under =~/.mbsync/=, you can either manually run mbsync or use emacs to update mail.

**** Org Mode
My org mode config includes two additional plugins, org-agenda and org-roam. Both these plugins need a set directory. All org files can go under the created =~/org= dir. Roam files go under =~/org/roam=

*** Fonts
[[https://github.com/shaunsingh/SFMono-Nerd-Font-Ligaturized][SFMono]] must be installed seperately due to liscensing issues, all other fonts are managed via nix.

*** Neovim
Run =:PackerSync= to install packer and plugins. Run =:checkhealth= to check for possible issues.
If you want to take advantage of the LSP and/or treesitter, you can install language servers and parsers using the following command:
=:LspInstall (language)=
=:TSInstall (language)=
*NOTE:* If you want to use neorg's treesitter parser on macOS, you need to link GCC to CC. Instructions [[https://github.com/nvim-neorg/neorg/issues/74#issuecomment-906627223][here]].
I also recommend installing [[https://github.com/Kethku/neovide][Neovide]]

* Flakes
** Why Flakes
Once upon a time, Nix pioneered reproducible builds: it tries hard to ensure that two builds of the same derivation graph produce an identical result. Unfortunately, the evaluation of Nix files into such a derivation graph isn’t nearly as reproducible, despite the language being nominally purely functional.

For example, Nix files can access arbitrary files (such as =~/.config/nixpkgs/config.nix=), environment variables, Git repositories, files in the Nix search path (=$NIX_PATH=), command-line arguments (=--arg=) and the system type (=builtins.currentSystem=). In other words, evaluation isn’t as hermetic as it could be. In practice, ensuring reproducible evaluation of things like NixOS system configurations requires special care.

Furthermore, there is no standard way to compose Nix-based projects. It’s rare that everything you need is in Nixpkgs; consider for instance projects that use Nix as a build tool, or NixOS system configurations. Typical ways to compose Nix files are to rely on the Nix search path (e.g. =import <nixpkgs>=) or to use =fetchGit= or =fetchTarball=. The former has poor reproducibility, while the latter provides a bad user experience because of the need to manually update Git hashes to update dependencies.

There is also no easy way to deliver Nix-based projects to users. Nix has a “channel” mechanism (essentially a tarball containing Nix files), but it’s not easy to create channels and they are not composable. Finally, Nix-based projects lack a standardized structure. There are some conventions (e.g. =shell.nix= or =release.nix=) but they don’t cover many common use cases; for instance, there is no way to discover the NixOS modules provided by a repository.

Flakes are a solution to these problems. A flake is simply a source tree (such as a Git repository) containing a file named =flake.nix= that provides a standardized interface to Nix artifacts such as packages or NixOS modules. Flakes can have dependencies on other flakes, with a “lock file” pinning those dependencies to exact revisions to ensure reproducible evaluation.

When you clone this flake and install it, your system should theoretically be the /exactly/ the same as mine, down to the commit of nixpkgs. There are also other benefits, such as that nix evaluations are cached.

** Notes on using the flake
When you install this config, there are 3 useful commands you need to know

- Updating the flake. This will update the =flake.lock= lockfile to the latest commit of nixpkgs, emacs-overlay, etc
#+begin_src bash
nix flake update
#+end_src

- Building and Installing the flake. This will first build and download everything you need, then =rebuild= your machine, so it "installs"
#+begin_src bash
nix build ~/nix-darwin-dotfiles\#darwinConfigurations.shaunsingh-laptop.system --extra-experimental-features nix-command --extra-experimental-features flakes
    ./result/sw/bin/darwin-rebuild switch --flake .#shaunsingh-laptop
#+end_src

- Testing the flake. If you have any errors when you play around with this config, then this will let you know what went wrong.
#+begin_src bash
nix flake check
#+end_src

The =flake.nix= below does the following:
1. Add a binary cache for =nix-community= overlays
2. Add inputs (=nixpkgs-master=, =nix-darwin=, =home-manager,= and =spacebar=)
3. Add overlays to get the latest versions of =neovim= (nightly) and =emacs= (emacs29)
4. Create a nix-darwin configuration for my hostname
5. Source the [[file:./modules/mac.nix][mac]], [[file:./modules/home.nix][home]], and [[file:./modules/pam.nix][pam]] modules
6. Configure home-manager and the nix-daemon
7. Enable the use of touch-id for sudo authentication
8. Configure =nixpkgs= to use the overlays above, and allow unfree packages
9. Configure =nix= to enable =flakes= and =nix-command= by default, and add =x86-64-darwin= as a platform (to install packages through rosetta)
10. Install my packages and config dependencies
11. Install the required fonts
#+begin_src nix :comments none :tangle "flake.nix"
{
  description = "Shaurya's Nix Environment";

  nixConfig.extra-substituters = "https://nix-community.cachix.org";
  nixConfig.extra-trusted-public-keys =
    "nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=";

  inputs = {
    # All packages should follow latest nixpkgs
    unstable.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    nur.url = "github:nix-community/NUR";
    # core
    darwin = {
      url = "github:LnL7/nix-darwin";
      inputs.nixpkgs.follows = "unstable";
    };
    nixos-hardware = {
      url = github:NixOS/nixos-hardware/master;
      inputs.nixpkgs.follows = "unstable";
    };
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "unstable";
    };
    # Bar
    spacebar = {
      url = "github:shaunsingh/spacebar";
      inputs.nixpkgs.follows = "unstable";
    };
    # WM
    yabai-src = {
      url = "github:koekeishiya/yabai";
      flake = false;
    };
    # Editors
    emacs-src = {
      url = "github:emacs-mirror/emacs";
      flake = false;
    };
    emacs-ng = {
      url = "github:emacs-ng/emacs-ng";
      inputs.nixpkgs.follows = "unstable";
    };
    emacs-vterm-src = {
      url = "github:akermu/emacs-libvterm";
      flake = false;
    };
    doom-emacs = {
      url = "github:hlissner/doom-emacs";
      flake = false;
    };
    # Themeing
    base16 = {
      url = "github:shaunsingh/base16-nix";
      inputs.nixpkgs.follows = "unstable";
    };
    # overlays
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "unstable";
    };
    neovim-overlay = {
      url = "github:nix-community/neovim-nightly-overlay";
      inputs.nixpkgs.follows = "unstable";
    };
  };
  outputs = { self, nixpkgs, darwin, home-manager, ... }@inputs: {
    darwinConfigurations."shaunsingh-laptop" = darwin.lib.darwinSystem {
      system = "aarch64-darwin";
      modules = [
        ./modules/mac.nix
        ./modules/pam.nix
        ./modules/editors.nix
        home-manager.darwinModule
        {
          home-manager = {
            useGlobalPkgs = true;
            useUserPackages = true;
            users.shauryasingh = {
              imports = [
                inputs.base16.hmModule
                ./modules/home.nix
                ./modules/theme.nix
              ];
            };
          };
        }
        ({ config, pkgs, lib, ... }: {
          services.nix-daemon.enable = true;
          security.pam.enableSudoTouchIdAuth = true;
          nixpkgs = {
            config.allowUnfree = true;
            overlays = with inputs; [
              nur.overlay
              spacebar.overlay
              neovim-overlay.overlay
              rust-overlay.overlay
              (final: prev: {
                doomEmacsRevision = inputs.doom-emacs.rev;
                sf-mono-liga-bin = pkgs.callPackage ./pkgs/sf-mono-liga-bin { };
                neovide = pkgs.callPackage ./pkgs/neovide { };
                yabai = let
                  version = "4.0.0-dev";
                  buildSymlinks = prev.runCommand "build-symlinks" { } ''
                    mkdir -p $out/bin
                    ln -s /usr/bin/xcrun /usr/bin/xcodebuild /usr/bin/tiffutil /usr/bin/qlmanage $out/bin
                  '';
                in prev.yabai.overrideAttrs (old: {
                  inherit version;
                  src = inputs.yabai-src;

                  buildInputs = with prev.darwin.apple_sdk.frameworks; [
                    Carbon
                    Cocoa
                    ScriptingBridge
                    prev.xxd
                    SkyLight
                  ];

                  nativeBuildInputs = [ buildSymlinks ];
                });
                emacs-vterm = prev.stdenv.mkDerivation rec {
                  pname = "emacs-vterm";
                  version = "master";

                  src = inputs.emacs-vterm-src;

                  nativeBuildInputs = [
                    prev.cmake
                    prev.libtool
                    prev.glib.dev
                  ];

                  buildInputs = [
                    prev.glib.out
                    prev.libvterm-neovim
                    prev.ncurses
                  ];

                  cmakeFlags = [
                    "-DUSE_SYSTEM_LIBVTERM=yes"
                  ];

                  preConfigure = ''
                    echo "include_directories(\"${prev.glib.out}/lib/glib-2.0/include\")" >> CMakeLists.txt
                    echo "include_directories(\"${prev.glib.dev}/include/glib-2.0\")" >> CMakeLists.txt
                    echo "include_directories(\"${prev.ncurses.dev}/include\")" >> CMakeLists.txt
                    echo "include_directories(\"${prev.libvterm-neovim}/include\")" >> CMakeLists.txt
                  '';

                  installPhase = ''
                    mkdir -p $out
                    cp ../vterm-module.so $out
                    cp ../vterm.el $out
                  '';

                };
                emacs = (prev.emacs.override {
                  srcRepo = true;
                  nativeComp = true;
                  withSQLite3 = true;
                  withXwidgets = true;
                }).overrideAttrs (o: rec {
                  version = "29.0.50";
                  src = inputs.emacs-src;

                  buildInputs = o.buildInputs ++ [ prev.darwin.apple_sdk.frameworks.WebKit ];

                  configureFlags = o.configureFlags ++ [
                    "--without-gpm"
                    "--without-dbus"
                    "--without-mailutils"
                    "--without-toolkit-scroll-bars"
                    "--without-pop"
                  ];

                  patches = [
                    ./patches/fix-window-role.patch
                    ./patches/system-appearance.patch
                    # ./patches/no-titlebar.patch
                  ];

                  postPatch = o.postPatch + ''
                    substituteInPlace lisp/loadup.el \
                    --replace '(emacs-repository-get-branch)' '"master"'
                  '';

                  postInstall = o.postInstall + ''
                    cp ${final.emacs-vterm}/vterm.el $out/share/emacs/site-lisp/vterm.el
                    cp ${final.emacs-vterm}/vterm-module.so $out/share/emacs/site-lisp/vterm-module.so
                  '';

                  CFLAGS =
                    "-DMAC_OS_X_VERSION_MAX_ALLOWED=110203 -g -O3 -mtune=native -march=native -fomit-frame-pointer";
                });
              })
            ];
          };
          nix = {
            package = pkgs.nix;
            extraOptions = ''
              system = aarch64-darwin
              extra-platforms = aarch64-darwin x86_64-darwin
              experimental-features = nix-command flakes
              build-users-group = nixbld
            '';
          };
          programs.fish.enable = true;
          environment.shells = with pkgs; [ fish ];
          users.users.shauryasingh = {
            home = "/Users/shauryasingh";
            shell = pkgs.fish;
          };
          system.activationScripts.postActivation.text = ''
            # Set the default shell as fish for the user
            sudo chsh -s ${lib.getBin pkgs.fish}/bin/fish shauryasingh
          '';
          environment.systemPackages = with pkgs; [
            # emacs needs to be here since its a GUI app
            emacs

            # Build Tools
            jdk
            rust-bin.nightly.latest.default

            # Language Servers
            nodePackages.pyright
            rust-analyzer

            # Formatting
            nixfmt
            black
            shellcheck

            # Terminal utils and rust alternatives :tm:
            xcp
            lsd
            procs
            tree
            zoxide
            bottom
            discocss
          ];
          fonts = {
            enableFontDir = true;
            fonts = with pkgs; [
              overpass
              fira
              emacs-all-the-icons-fonts
              sf-mono-liga-bin
            ];
          };
        })
      ];
    };
    nixosConfigurations = {
      shaunsingh-thinkpad = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
        modules = [
          ./modules/editors.nix
          ./hardware/thinkpad-hardware-configuration.nix
          inputs.nixos-hardware.nixosModules.lenovo-thinkpad-x1
          inputs.nixos-hardware.nixosModules.lenovo-thinkpad-x1-7th-gen
          home-manager.nixosModules.home-manager
          {
            home-manager = {
              useGlobalPkgs = true;
              useUserPackages = true;
              users.shauryasingh = {
                imports = [
                  inputs.base16.hmModule
                  ./modules/home.nix
                  ./modules/theme.nix
                ];
              };
            };
          }
          ({ config, pkgs, lib, ... }: {
            nixpkgs = {
              config.allowUnfree = true;
              overlays = with inputs; [
                nur.overlay
                spacebar.overlay
                neovim-overlay.overlay
                rust-overlay.overlay
                (final: prev: {
                  doomEmacsRevision = inputs.doom-emacs.rev;
                  sf-mono-liga-bin = pkgs.callPackage ./pkgs/sf-mono-liga-bin { };
                  emacs-vterm = prev.stdenv.mkDerivation rec {
                    pname = "emacs-vterm";
                    version = "master";

                    src = inputs.emacs-vterm-src;

                    nativeBuildInputs = [
                      prev.cmake
                      prev.libtool
                      prev.glib.dev
                    ];

                    buildInputs = [
                      prev.glib.out
                      prev.libvterm-neovim
                      prev.ncurses
                    ];

                    cmakeFlags = [
                      "-DUSE_SYSTEM_LIBVTERM=yes"
                    ];

                    preConfigure = ''
                      echo "include_directories(\"${prev.glib.out}/lib/glib-2.0/include\")" >> CMakeLists.txt
                      echo "include_directories(\"${prev.glib.dev}/include/glib-2.0\")" >> CMakeLists.txt
                      echo "include_directories(\"${prev.ncurses.dev}/include\")" >> CMakeLists.txt
                      echo "include_directories(\"${prev.libvterm-neovim}/include\")" >> CMakeLists.txt
                    '';

                    installPhase = ''
                      mkdir -p $out
                      cp ../vterm-module.so $out
                      cp ../vterm.el $out
                    '';

                  };
                })
              ];
            };
            nix = {
              package = pkgs.nix;
              extraOptions = ''
                experimental-features = nix-command flakes
                build-users-group = nixbld
              '';
            };

            # Use fish, launch exwm after login
            programs.fish = {
              enable = true;
              loginShellInit = ''
                if test (id --user $USER) -ge 1000 && test (tty) = "/dev/tty1"
                   exec >~/.logs/xsession 2>&1
                   export LANG="en_GB.UTF-8"
                   export LANGUAGE="en_GB.UTF-8"
                   export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u)/bus
                   export _JAVA_AWT_WM_NONREPARENTING=1
                   wmname LG3D
                   xset -dpms
                   xset s off
                   xhost +SI:localuser:$USER
                   emacs -mm --with-exwm
                end
              '';
            };

            # enable the xserver
            services.xserver = {
              enable = true;
              libinput = {
                enable = true;
              };
            };

            # Define a user account. Don't forget to set a password with ‘passwd’.
            users.users.shauryasingh = {
              isNormalUser = true;
              extraGroups =
                [ "wheel" "networkManager" ]; # Enable ‘sudo’ for the user.
              shell = pkgs.fish;
            };

            # Power management
            services.power-profiles-daemon.enable = true;
            powerManagement.cpuFreqGovernor = lib.mkDefault "performance";
            services.thermald.enable = true;
            hardware.enableRedistributableFirmware = true;

            # Network settings.
            networking = {
              hostName = "shaunsingh-thinkpad"; # Hostname
              useDHCP = false; # Deprecated, so set explicitly to false
              wireless.enable = false;
              networkmanager.enable = true; # Enable networkmanager
            };

            # Bootloader
            boot.loader.efi.canTouchEfiVariables = true;
            boot.loader.systemd-boot.enable = true;

            # Set your time zone.
            time.timeZone = "America/New_York";

            # Select internationalisation properties.
            i18n.defaultLocale = "en_US.UTF-8";
            console = {
              font = "Lat2-Terminus16";
              keyMap = "us";
            };

            # Sound
            sound.enable = false;
            hardware.pulseaudio.enable = false; # Pulseaudio

            services.pipewire = {
              enable = true;
              alsa.enable = true;
              alsa.support32Bit = true;
              pulse.enable = true;
              jack.enable = true;
            };

            environment.systemPackages = with pkgs; [
              # emacs needs to be here since its a GUI app
              emacs

              # Build Tools
              jdk
              rust-bin.nightly.latest.default

              # Language Servers
              nodePackages.pyright
              rust-analyzer

              # Formatting
              nixfmt
              black
              shellcheck

              # Terminal utils and rust alternatives :tm:
              xcp
              lsd
              procs
              tree
              zoxide
              bottom
              discocss
            ];
            fonts = {
              enableFontDir = true;
              fonts = with pkgs; [
                overpass
                fira
                emacs-all-the-icons-fonts
                sf-mono-liga-bin
              ];
            };
          })
        ];
      };
    };
  };
}
#+end_src

* Modules
** Theme.nix
We need to define the theme we're using before we get started
#+begin_src nix :comments none :tangle "./modules/theme.nix"
{ pkgs, lib, config, inputs, ...}:
{
  config = {
    themes.base16 = {
      enable = true;
      scheme = "nord";
      # defaultTemplateType = "default";
    };
  }
}
#+end_src

** Home.nix
Home Manager allows you to use Nix’s declarative approach to manage your user-level configuration and packages. It works on any *nix system supported by Nix, including MacOS.
#+begin_src nix :comments none :tangle "./modules/home.nix"
{ pkgs, lib, config, home-manager, nix-darwin, inputs, ... }: {
#+end_src

*** Git
As opposed to what the xcode CLT provides, I want lfs enabled with git, and use =delta= instead of the default diff tool (rust alternatives go brr). MacOS is also quite annoying with its =.DS_Store='s everywhere, so lets ignore that
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.git = {
    enable = true;
    userName = "shaunsingh";
    userEmail = "shaunsingh0207@gmail.com";
    delta = {
      enable = true;
      options = {
        syntax-theme = "Nord";
        line-numbers = true;
      };
    };
    ignores = [ ".dir-locals.el" ".envrc" ".DS_Store" ];
  };
#+end_src

*** IdeaVim
Intellij Idea ships with a very nice Vim emulation plugin. This is configured via a vimrc-like file (=~/.ideavimrc=). Since it doesn't have proper support in home-manger, we can just generate a file and symlink it into place
#+begin_src nix :comments none :tangle "./modules/home.nix"
  home.file = {
    ".ideavimrc".text = ''
      " settings
      set ignorecase
      set smartcase
      set scrolloff=3 " 3 lines above/below cursor when scrolling
      set nonumber
      set clipboard+=unnamed
      set multiple-cursors
      set numberwidth=2
      set expandtab=true
      set shiftwidth=4

      " plugins
      set easymotion
      set NERDTree
      set surround
      set highlightedyank


      " bindings
      let mapleader = " "
      nmap <leader>. :action GotoFile<cr>
      nmap <leader>fr :action RecentFiles<cr>
      nmap <leader>ww <Plug>(easymotion-w)
      nmap <leader>tz :action Enter Zen Mode<cr>
      nmap <leader>op :NERDTreeToggle<cr>
      nmap <leader>ot :Terminal<cr>
      nmap <leader>: :action SearchEverywhere<cr>
      nmap <leader>/ :action Find<cr>

      " use ; to enter command
      nmap ; :

      " use jk for escaping
      inoremap jk <Esc>
      cnoremap jk <Esc>

      " move by visual lines"
      nmap j gj
      nmap k gk

      " use C-hjkl to navigate splits
      nmap <C-h> <c-w>h
      nmap <C-l> <c-w>l
      nmap <C-k> <c-w>k
      nmap <C-j> <c-w>j

      nmap <leader>E :action Tool_External Tools_emacsclient<cr>
    '';
 };
#+end_src

*** Discocss
Discord is an app I use almost every day, so lets spice it up a bit. Still, its a pain to work with CSS files without highlighting so I'll just have HM link a file instead.
#+begin_src nix :comments none :tangle "./modules/home.nix"
  xdg.dataFile."discocss/custom.css".source = ../configs/custom.css;
#+end_src

*** Firefox
Although safari is my main browser, firefox looks very appealing with its excellent privacy and speed
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.firefox.enable = true;
#+end_src

GUI apps are very finicky with nix, and so I create a fake package so that we can still use the configuration from =home-manager= without having to install it via nix. The user can then install firefox manually to =~/Applications=
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.firefox.package =
    pkgs.runCommand "firefox-0.0.0" { } "mkdir $out";
  programs.firefox.extensions =
      with pkgs.nur.repos.rycee.firefox-addons; [
        ublock-origin
        tridactyl
        reddit-enhancement-suite
        betterttv
        theme-nord-polar-night
      ];
#+end_src

Now for the configuration. We want firefox to use the css at [[file:./configs/userChrome.css]], and we want to configure the UI. Lets also enable the (rust powered ftw) webrender/servo renderer.
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.firefox.profiles = let
    userChrome = builtins.readFile ../configs/userChrome.css;
    settings = {
      "browser.startup.homepage" = "https://searx.tiekoetter.com/";
      "browser.ctrlTab.recentlyUsedOrder" = false;
      "browser.newtabpage.enabled" = false;
      "browser.bookmarks.showMobileBookmarks" = true;
      "browser.uidensity" = 1;
      "browser.urlbar.placeholderName" = "Search Using SearXNG";
      "browser.urlbar.update1" = true;
      "privacy.trackingprotection.enabled" = true;
      "privacy.trackingprotection.socialtracking.enabled" = true;
      "privacy.trackingprotection.socialtracking.annotate.enabled" = true;
      "reader.color_scheme" = "sepia";
      "services.sync.declinedEngines" = "addons,prefs";
      "services.sync.engine.addons" = false;
      "services.sync.engineStatusChanged.addons" = true;
      "services.sync.engine.prefs" = false;
      "services.sync.engineStatusChanged.prefs" = true;
      "gfx.webrender.all" = true;
      "trim_on_minimize" = true;
      "toolkit.legacyUserProfileCustomizations.stylesheets" = true;
    };
  in {
    home = {
      inherit settings;
      inherit userChrome;
      id = 0;
    };
  };
#+end_src

*** Alacritty
Alacritty is my terminal emulator of choice. Similar to firefox, we want to create a fake package, and then configure it as normal
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.alacritty = {
    enable = true;
    package = pkgs.runCommand "alacritty-0.0.0" { } "mkdir $out";
    settings = with config.lib.base16.theme; {
      window.padding.x = 45;
      window.padding.y = 45;
      window.decorations = "transparent";
      window.dynamic_title = true;
      live_config_reload = true;
      mouse.hide_when_typing = true;
      use_thin_strokes = true;
      cursor.style = "Beam";

      font = {
        size = 15;
        normal.family = "Liga SFMono Nerd Font";
        normal.style = "Light";
        bold.family = "Liga SFMono Nerd Font";
        bold.style = "Bold";
        italic.family = "Liga SFMono Nerd Font";
        italic.style = "Italic";
      };

      colors = {
        cursor.cursor = "#${base04-hex}";
        primary.background = "#${base00-hex}";
        primary.foreground = "#${base06-hex}";
        normal = {
          black =   "#${base00-hex}";
          red =     "#${base0B-hex}";
          green =   "#${base0C-hex}";
          yellow =  "#${base0D-hex}";
          blue =    "#${base07-hex}";
          magenta = "#${base0F-hex}";
          cyan =    "#${base09-hex}";
          white =   "#${base04-hex}";
        };
        bright = {
          black =   "#${base03-hex}";
          red =     "#${base0B-hex}";
          green =   "#${base0C-hex}";
          yellow =  "#${base0D-hex}";
          blue =    "#${base07-hex}";
          magenta = "#${base0F-hex}";
          cyan =    "#${base09-hex}";
          white =   "#${base06-hex}";
        };
      };
    };
  };
#+end_src

*** Fish
**** Aliases
I also like to alias common commands with other, better rust alternatives :tm:
#+begin_src nix :comments none :tangle "./modules/home.nix"
programs.fish.enable = true;
programs.fish.shellAliases = with pkgs; {
    ":q" = "exit";
    vi = "emacsclient -c";
    git-rebsae = "git rebase -i HEAD~2";
    ls = "lsd";
    ps = "ps";
    tree = "tree -a -C";
    cat = "bat";
    top = "btm";
    cp = "xcp";
    find = "fd";
    calc = "emacs -f full-calc";
  };
#+end_src

**** Init
I like to make my prompt look pretty (along with some =nix-shell= and =git= integration)
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.fish.interactiveShellInit = ''
    set -g fish_greeting ""
    zoxide init fish --cmd cd | source
    set -x EDITOR "nvim"
    set -x PATH ~/.config/emacs/bin $PATH

    set -g fish_greeting ""
    set -U fish_color_autosuggestion      brblack
    set -U fish_color_cancel              -r
    set -U fish_color_command             green
    set -U fish_color_comment             magenta
    set -U fish_color_cwd                 green
    set -U fish_color_cwd_root            red
    set -U fish_color_end                 magenta
    set -U fish_color_error               red
    set -U fish_color_escape              cyan
    set -U fish_color_history_current     --bold
    set -U fish_color_host                normal
    set -U fish_color_normal              normal
    set -U fish_color_operator            cyan
    set -U fish_color_param               blue
    set -U fish_color_quote               yellow
    set -U fish_color_redirection         yellow
    set -U fish_color_search_match        'yellow' '--background=brightblack'
    set -U fish_color_selection           'white' '--bold' '--background=brightblack'
    set -U fish_color_status              red
    set -U fish_color_user                green
    set -U fish_color_valid_path          --underline
    set -U fish_pager_color_completion    normal
    set -U fish_pager_color_description   yellow
    set -U fish_pager_color_prefix        'white' '--bold' '--underline'
    set -U fish_pager_color_progress      'white' '--background=cyan'

    # prompt
    set fish_prompt_pwd_dir_length 1
    set __fish_git_prompt_show_informative_status 1

    set fish_color_command green
    set fish_color_param $fish_color_normal

    set __fish_git_prompt_showdirtystate 'yes'
    set __fish_git_prompt_showupstream 'yes'

    set __fish_git_prompt_color_branch brown
    set __fish_git_prompt_color_dirtystate FCBC47
    set __fish_git_prompt_color_stagedstate yellow
    set __fish_git_prompt_color_upstream cyan
    set __fish_git_prompt_color_cleanstate green
    set __fish_git_prompt_color_invalidstate red

    set __fish_git_prompt_char_dirtystate '~~'
    set __fish_git_prompt_char_stateseparator ' '
    set __fish_git_prompt_char_untrackedfiles ' ...'
    set __fish_git_prompt_char_cleanstate '✓'
    set __fish_git_prompt_char_stagedstate '-> '
    set __fish_git_prompt_char_conflictedstate "✕"

    set __fish_git_prompt_char_upstream_prefix ""
    set __fish_git_prompt_char_upstream_equal ""
    set __fish_git_prompt_char_upstream_ahead '>>='
    set __fish_git_prompt_char_upstream_behind '=<<'
    set __fish_git_prompt_char_upstream_diverged '<=>'

    function _print_in_color
      set -l string $argv[1]
      set -l color  $argv[2]

      set_color $color
      printf $string
      set_color normal
    end

    function _prompt_color_for_status
      if test $argv[1] -eq 0
        echo magenta
      else
        echo red
      end
    end

    function fish_prompt
        set -l last_status $status

        set -l nix_shell_info (
          if test -n "$IN_NIX_SHELL"
            echo -n " [nix-shell]"
          end
        )

        if test $HOME != $PWD
            _print_in_color ""(prompt_pwd) blue
        end
        __fish_git_prompt " (%s)"

        _print_in_color "$nix_shell_info λ " (_prompt_color_for_status $last_status) ]

    end
  '';
#+end_src

*** Bat
Bat is another rust alternative :tm: to cat, and provides syntax highlighting. Lets theme it to match nord
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.bat = {
    enable = true;
    config = { theme = "Nord"; };
  };
#+end_src

*** Tmux
Lastly, lets make tmux look just as pretty as our prompt, and enable truecolor support.
#+begin_src nix :comments none :tangle "./modules/home.nix"
  programs.tmux.enable = true;
  programs.tmux.extraConfig = ''
    # make sure fish works in tmux
    set -g default-terminal "screen-256color"
    set -sa terminal-overrides ',xterm-256color:RGB'
    # so that escapes register immidiately in vim
    set -sg escape-time 1
    set -g focus-events on
    # mouse support
    set -g mouse on
    # change prefix to C-a
    set -g prefix C-a
    bind C-a send-prefix
    unbind C-b
    # extend scrollback
    set-option -g history-limit 5000
    # vim-like pane resizing
    bind -r C-k resize-pane -U
    bind -r C-j resize-pane -D
    bind -r C-h resize-pane -L
    bind -r C-l resize-pane -R
    # vim-like pane switching
    bind -r k select-pane -U
    bind -r j select-pane -D
    bind -r h select-pane -L
    bind -r l select-pane -R
    # styling
    set -g status-style fg=black,bg=default
    set -g status-left ""
    set -g status-right ""
    set -g status-justify centre
    set -g status-position bottom
    set -g pane-active-border-style bg=default,fg=default
    set -g pane-border-style fg=default
    set -g window-status-current-format "#[fg=cyan]#[fg=white]#[bg=cyan]#I #[bg=brightwhite]#[fg=black] #W#[fg=brightwhite]#[bg=default] #[bg=default] #[fg=magenta]#[fg=white]#[bg=magenta]λ #[fg=black]#[bg=brightwhite] %a %d %b #[fg=magenta]%R#[fg=brightwhite]#[bg=default]"
    set -g window-status-format "#[fg=magenta]#[fg=white]#[bg=magenta]#I #[bg=brightwhite]#[fg=black] #W#[fg=brightwhite]#[bg=default] "
  '';
}
#+end_src

** Editors.nix
My editor configurations have grown out of control, so lets tame them a bit.
#+begin_src nix :comments none :tangle "./modules/editors.nix"
{ pkgs, lib, home-manager, ... }:
#+end_src

*** Doom-emacs
Nix via doom-emacs is very, /very/ annoying. Initially I was using [[https://github.com/vlaci/nix-doom-emacs][Nix-doom-emacs]]. However, this has a few drawbacks
1. It doesn't support straight =:recipe=, so all packages must be from melpa or elpa
2. It pins the version of doom, so you need to update doom and its dependencies painstakingly manually
3. It just ends up breaking anyways.

A simpler solution is just to have nix clone =doom-emacs= to =~/.config/emacs=, and the user can handle doom manually. The doom version is pinned in the =flake.lock= of the repository, but a =doom upgrade= will override it. Since I have an arm based macbook, I also use nix to install and manage my treesitter parsers instead of compiling them myself
#+begin_src nix :comments none :tangle "./modules/editors.nix"
let
  emacsSyncScript = pkgs.writeScriptBin "doom-sync-git" ''
    #!${pkgs.runtimeShell}
    export PATH=$PATH:${lib.makeBinPath [ pkgs.git pkgs.sqlite pkgs.unzip ]}
    if [ ! -d $HOME/.config/emacs/.git ]; then
      mkdir -p $HOME/.config/emacs
      git -C $HOME/.config/emacs init
    fi
    if [ $(git -C $HOME/.config/emacs rev-parse HEAD) != ${pkgs.doomEmacsRevision} ]; then
      git -C $HOME/.config/emacs fetch https://github.com/hlissner/doom-emacs.git || true
      git -C $HOME/.config/emacs checkout ${pkgs.doomEmacsRevision} || true
    fi
  '';
  langs = [
    "nix"
    "java"
    "python"
    "rust"
    "elisp"
    "comment"
  ];
  grammars = lib.getAttrs (map (lang: "tree-sitter-${lang}") langs) pkgs.tree-sitter.builtGrammars;
in
{
  home-manager.users.shauryasingh.home.packages = with pkgs; [
    (ripgrep.override { withPCRE2 = true; })
    fd
    sqlite
    gnuplot
    pandoc
    sdcv
    (aspellWithDicts (ds: with ds; [ en en-computers en-science ]))
    tectonic
    emacsSyncScript
    mu
    isync
    languagetool
    neovim-nightly
    # neovide
    nodejs-16_x
    tree-sitter
  ];
  home-manager.users.shauryasingh.home.file.".config/tree-sitter".source = (pkgs.runCommand "grammars" {} ''
    mkdir -p $out/bin
    ${lib.concatStringsSep "\n"
      (lib.mapAttrsToList (name: src: "name=${name}; ln -s ${src}/parser $out/bin/\${name#tree-sitter-}.so") grammars)};
  '');
  services.emacs = {
    enable = true;
    package = pkgs.emacs;
  };
#+end_src

*** Neovim
Lastly, I didn't feel like nix-ifying my neovim lua config, so thats just a submodule. We can use nix to manage tree-sitter grammers, as well as fzf-native
#+begin_src nix :comments none :tangle "./modules/editors.nix"
  # fzf-native
  home-manager.users.shauryasingh.xdg.dataFile."nvim/site/pack/packer/start/telescope-fzf-native.nvim/build/libfzf.so".source = "${pkgs.vimPlugins.telescope-fzf-native-nvim}/build/libfzf.so";
  # tree-sitter parsers
  home-manager.users.shauryasingh.xdg.configFile."nvim/parser/lua.so".source = "${pkgs.tree-sitter.builtGrammars.tree-sitter-lua}/parser";
  home-manager.users.shauryasingh.xdg.configFile."nvim/parser/nix.so".source = "${pkgs.tree-sitter.builtGrammars.tree-sitter-nix}/parser";
}
#+end_src

** Mac.nix
There are mac-specific tweaks I need to do. In the future if I switch to nixOS full-time, then I wuold likely need to remove the mac-specific packages. An easy way to do this is just keep them in a seperate file:
#+begin_src nix :comments none :tangle "./modules/mac.nix"
{ config, pkgs, lib, ... }: {
#+end_src

*** Yabai
Yabai is my tiling WM of choice. As this is an m1 (=aarch64-darwin=) laptop, I use the =the-future= branch, which enables the SA addon on m1 machines and monterey support

Now to configure the package via nix
#+begin_src nix :comments none :tangle "./modules/mac.nix"
  services.yabai = {
    enable = true;
    enableScriptingAddition = true;
    package = pkgs.yabai;
    config = {
      # layout
      layout = "bsp";
      auto_balance = "on";
      split_ratio = "0.50";
      window_placement = "second_child";
      # Gaps
      window_gap = 18;
      top_padding = 18;
      bottom_padding = 46;
      left_padding = 18;
      right_padding = 18;
      # shadows and borders
      window_shadow = "on";
      window_border = "off";
      window_border_width = 3;
      window_opacity = "on";
      window_opacity_duration = "0.1";
      active_window_opacity = "1.0";
      normal_window_opacity = "1.0";
      # mouse
      mouse_modifier = "cmd";
      mouse_action1 = "move";
      mouse_action2 = "resize";
      mouse_drop_action = "swap";
    };
    extraConfig = ''
      # rules
      yabai -m rule --add app=emacs-28.0.90 manage=on
      yabai -m rule --add app='Firefox Nightly' manage=on
      yabai -m rule --add app='System Preferences' manage=off
      yabai -m rule --add app='Activity Monitor' manage=off
    '';
  };
#+end_src

*** Spacebar
Spacebar is my bar of choice on macOS. Its lighter than any web-based ubersicht bar, and looks nice
#+begin_src nix :comments none :tangle "./modules/mac.nix"
  services.spacebar = {
    enable = true;
    package = pkgs.spacebar;
    config = {
      position = "bottom";
      height = 28;
      title = "on";
      spaces = "on";
      power = "on";
      clock = "off";
      right_shell = "off";
      padding_left = 20;
      padding_right = 20;
      spacing_left = 25;
      spacing_right = 25;
      text_font = ''"Menlo:16.0"'';
      icon_font = ''"Menlo:16.0"'';
      # Light theme colors:
      ## background_color = "0xffffffff";
      ## foreground_color = "0xff37474F";
      ## space_icon_color = "0xff673AB7";
      # Dark theme colors:
      background_color = "0xff2E3440";
      foreground_color = "0xffECEFF4";
      space_icon_color = "0xff81A1C1";
      power_icon_strip = " ";
      space_icon_strip = "一 二 三 四 五 六 七 八 九 十";
      spaces_for_all_displays = "on";
      display_separator = "on";
      display_separator_icon = "|";
      clock_format = ''"%d/%m/%y %R"'';
      right_shell_icon = " ";
      right_shell_command = "whoami";
    };
  };
#+end_src

*** SKHD
Skhd is the hotkey daemon for yabai. As yabai is disabled, it makes sense to disable skhd too for the time being
#+begin_src nix :comments none :tangle "./modules/mac.nix"
  services.skhd = {
    enable = true;
    package = pkgs.skhd;
    skhdConfig = ''
      # open terminal
      cmd - return : alacritty

      # open emacs
      cmd - e : emacs
      cmd + lalt -e : emacsclient --eval "(emacs-everywhere)"
      cmd + shift -e : emacsclient --eval "(emacs-everywhere)"

      # focus window
      lalt - h : yabai -m window --focus west
      lalt - j : yabai -m window --focus south
      lalt - k : yabai -m window --focus north
      lalt - l : yabai -m window --focus east
          
      # swap managed window
      shift + lalt - h : yabai -m window --swap west
      shift + lalt - l : yabai -m window --swap east
      shift + lalt - j : yabai -m window --swap south
      shift + lalt - k : yabai -m window --swap north

      # focus spaces
      alt - x : yabai -m space --focus recent
      alt - 1 : yabai -m space --focus 1
      alt - 2 : yabai -m space --focus 2
      alt - 3 : yabai -m space --focus 3
      alt - 4 : yabai -m space --focus 4
      alt - 5 : yabai -m space --focus 5
      alt - 6 : yabai -m space --focus 6
      alt - 7 : yabai -m space --focus 7
      alt - 8 : yabai -m space --focus 8

      # focus on next/prev space
      alt + ctrl - q : yabai -m space --focus prev
      alt + ctrl - e : yabai -m space --focus next

      # send window to desktop
      shift + alt - x : yabai -m window --space recent
      shift + alt - 1 : yabai -m window --space 1
      shift + alt - 2 : yabai -m window --space 2
      shift + alt - 3 : yabai -m window --space 3
      shift + alt - 4 : yabai -m window --space 4
      shift + alt - 5 : yabai -m window --space 5
      shift + alt - 6 : yabai -m window --space 6
      shift + alt - 7 : yabai -m window --space 7
      shift + alt - 8 : yabai -m window --space 8

      # float / unfloat window and center on screen
      lalt - t : yabai -m window --toggle float;\
                 yabai -m window --grid 4:4:1:1:2:2

      # toggle window zoom
      lalt - d : yabai -m window --toggle zoom-parent

   '';
  };
#+end_src

*** Homebrew
GUI apps with Nix are finicky at best. As much as I would like to fully give up homebrew, its very annoying having to re-install GUI apps on new systems
#+begin_src nix :comments none :tangle "./modules/mac.nix"
homebrew = {
    brewPrefix = "/opt/homebrew/bin";
    enable = true;
    autoUpdate = true;
    cleanup = "zap"; # keep it clean
    global = {
      brewfile = true;
      noLock = true;
    };

    taps = [
      "homebrew/core" # core
      "homebrew/cask" # we're using this for casks, after all
      "homebrew/cask-versions" # needed for firefox-nightly and discord-canary
    ];

    casks = [
      "firefox-nightly" # my browser of choice
      "discord-canary" # chat client of choice
      "nvidia-geforce-now" # game streaming
      "via" # keyboard config
      "blender" # blender
      "prusaslicer" # 3d printing
      "balenaetcher" # flashing usbs/sd
    ];
  };
#+end_src

*** MacOS Settings
I like my hostname to be the same as the flake's target
#+begin_src nix :comments none :tangle "./modules/mac.nix"
  networking.hostName = "shaunsingh-laptop";
  system.stateVersion = 4;
#+end_src

Along with that, lets
- Increase key repeat rate
- Remap Caps to Esc
- Save screenshots to =/tmp=
- Autohide the dock and menubar
- Show extensions in Finder (and allow it to "quit")
- Set macOS to use the dark theme
- Configure Trackpad and mouse behavior
- Enable subpixel antialiasing on internal/external displays
#+begin_src nix :comments none :tangle "./modules/mac.nix"
  system.keyboard = {
    enableKeyMapping = true;
    remapCapsLockToEscape = true;
  };
  system.defaults = {
    screencapture = { location = "/tmp"; };
    dock = {
      autohide = true;
      showhidden = true;
      mru-spaces = false;
    };
    finder = {
      AppleShowAllExtensions = true;
      QuitMenuItem = true;
      FXEnableExtensionChangeWarning = true;
    };
    NSGlobalDomain = {
      AppleKeyboardUIMode = 3;
      ApplePressAndHoldEnabled = false;
      AppleFontSmoothing = 1;
      _HIHideMenuBar = true;
      InitialKeyRepeat = 10;
      KeyRepeat = 1;
      "com.apple.mouse.tapBehavior" = 1;
      "com.apple.swipescrolldirection" = true;
    };
  };
}
#+end_src

** Pam.nix
Apple's touchid is an excellent way of authenticating anything quickly and securely. Sadly, =sudo= doesn't support it by default, but its an easy fix. T do this, we edit =/etc/pam.d/sudo= via =sed= to include the relevent code to enable touchid.

We don't use =environment.etc= because this would require that the user manually delete
=/etc/pam.d/sudo= which seems unwise given that applying the nix-darwin configuration requires
=sudo=. We also can't use =system.patches= since it only runs once, and so won't patch in the
changes again after OS updates (which remove modifications to this file).

As such, we resort to line addition/deletion in place using =sed=. We add a comment to the
added line that includes the name of the option, to make it easier to identify the line that
should be deleted when the option is disabled.

#+begin_src nix :comments none :tangle "./modules/pam.nix"
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.security.pam;
  mkSudoTouchIdAuthScript = isEnabled:
    let
      file = "/etc/pam.d/sudo";
      option = "security.pam.enableSudoTouchIdAuth";
    in ''
      ${if isEnabled then ''
        # Enable sudo Touch ID authentication, if not already enabled
        if ! grep 'pam_tid.so' ${file} > /dev/null; then
          sed -i "" '2i\
        auth       sufficient     pam_tid.so # nix-darwin: ${option}
          ' ${file}
        fi
      '' else ''
        # Disable sudo Touch ID authentication, if added by nix-darwin
        if grep '${option}' ${file} > /dev/null; then
          sed -i "" '/${option}/d' ${file}
        fi
      ''}
    '';

in {
  options = {
    security.pam.enableSudoTouchIdAuth = mkEnableOption ''
      Enable sudo authentication with Touch ID
      When enabled, this option adds the following line to /etc/pam.d/sudo:
          auth       sufficient     pam_tid.so
      (Note that macOS resets this file when doing a system update. As such, sudo
      authentication with Touch ID won't work after a system update until the nix-darwin
      configuration is reapplied.)
    '';
  };

  config = {
    system.activationScripts.extraActivation.text = ''
      # PAM settings
      echo >&2 "setting up pam..."
      ${mkSudoTouchIdAuthScript cfg.enableSudoTouchIdAuth}
    '';
  };
}
#+end_src

* Editors
** Emacs
#+include: "~/.config/doom/config.org"
** Neovim
There are many neovim configurations that exist (i.e. NvChad, Lunar Vim, etc.). However, many of these configurations suffer from a host of problems:

Some configurations (like NvChad), have very abstracted and complex codebases. Others rely on having as much overall functionality as possible (like LunarVim). While none of this is bad, there are some problems that can arise from these choices:

Complex codebases lead to less freedom for end-user extensiblity and configuration, as there is more reliance on the maintainer of said code. Users may not use half of what is made avalible to them simply because they don't need all of that functionality, so all of it may not be necessary. This config provides a solution to these problems by providing only the necessary code in order to make a functioning configuration. The end goal of this personal neovim config is to be used as a base config for users to extend and add upon, leading to a more unique editing experience.

The configuration was originally based off of [[https://github.com/NvChad/NvChad/tree/29f04fcc9d7a5e0cc9ef3a59ce5860d4cfa60f85][commit 29f04fc]] of NvChad, but this config has evolved to be much more than that.

You can now find it seperately on github, here: https://github.com/shaunsingh/nyoom.nvim

*** Develop
When sharing the config, it makes it much easier to handle dependencies with nix. This ensures installing dependencies (including neovim-nightly), as well as adding the new neovim build to path
#+include: "./configs/nyoom.nvim/flake.nix" src nix
#+include: "./configs/nyoom.nvim/shell.nix" src nix
*** Init
The init.lua first loads impatient.nvim if available (so we can cache the =.lua= files). It then disables builtin vim plugins, and loads the required modules for startup (=packer_compiled.lua=, =mappings.lua=, and =options.lua=)
#+include: "./configs/nyoom.nvim/init.lua" src lua
*** Packer
My packer configuration is broken into two files: =packerInit= and =pluginList=.
=packerInit= downloads packer if it isn't present, lazy loads it if it is, and configures packer. Notably:
- Put the =packer_compiled= file under =/nvim/lua= instead of =/nvim/plugin= so it can be chached by impatient.nvim
- Use packer in a floating window instead of a split, and remove the borders
- Increaes =clone_timeout=, just in case I'm on a more finicky network
=pluginList= contains the list of plugins, as well lazy loads and defines their configuration files.
#+include: "./configs/nyoom.nvim/lua/packerInit.lua" src lua
#+include: "./configs/nyoom.nvim/lua/pluginList.lua" src lua
*** Settings
As I said earlier, there are 3 required modules for startup (=packer_compiled.lua=, =mappings.lua=, and =options.lua=). Of that, =packer_compiled.lua= is generated using =:PackerCompile=, so we will focus on the other two.
- =mappings.lua= contains all of my mappings. All of the mappings are the same as the defaults for Doom Emacs (with a few exceptions). To list all of the keybinds, run =SPC h b b= in doom (or =SPC h b f= for major-mode specific binds). The file also contains some commands, which allow for the lazy loading of packer.
- =options.lua= contains all the basic options I want set before loading a buffer. Additionally, I want to disable the tilde fringe and =filetype.vim= (replaced with =filetype.nvim=).
#+include: "./configs/nyoom.nvim/lua/mappings.lua" src lua
#+include: "./configs/nyoom.nvim/lua/options.lua" src lua
*** Plugin Configuration
**** Bufferline
#+include: "./configs/nyoom.nvim/lua/plugins/bufferline.lua" src lua
**** Nvim-cmp
#+include: "./configs/nyoom.nvim/lua/plugins/cmp.lua" src lua
**** Gitsigns
#+include: "./configs/nyoom.nvim/lua/plugins/gitsigns.lua" src lua
**** Lspconfig
#+include: "./configs/nyoom.nvim/lua/plugins/lspconfig.lua" src lua
**** Neogit
#+include: "./configs/nyoom.nvim/lua/plugins/neogit.lua" src lua
**** Neorg
#+include: "./configs/nyoom.nvim/lua/plugins/neorg.lua" src lua
**** Nvimtree
#+include: "./configs/nyoom.nvim/lua/plugins/nvimtree.lua" src lua
**** Others
#+include: "./configs/nyoom.nvim/lua/plugins/others.lua" src lua
**** Statusline
#+include: "./configs/nyoom.nvim/lua/plugins/statusline.lua" src lua
**** Telescope
#+include: "./configs/nyoom.nvim/lua/plugins/telescope.lua" src lua
**** Treesitter
#+include: "./configs/nyoom.nvim/lua/plugins/treesitter.lua" src lua
**** Zenmode
#+include: "./configs/nyoom.nvim/lua/plugins/zenmode.lua" src lua
*** External
These are plugin I'm currently developing, but don't want ready for public release yet. As such, they reside in the =nyoom.nvim/lua/ext= directory.
**** doom.nvim
This is an experimental port of =doom-vibrant= to neovim, just me playing around with the new highlight API
#+include: "./configs/nyoom.nvim/lua/ext/doom.nvim/lua/doom.lua" src lua
**** Statusline.nvim
Just a little statusline to mess around with
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/statusline.lua" src lua
***** Modules
This is the fun part!
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/modules/config.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/modules/statusline.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/modules/utils.lua" src lua
***** Sections
All the sections of the statusline, lsp, git, etc,
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_bufeditable.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_buficon.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_bufmodified.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_bufname.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_filesize.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_git_branch.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_lsp.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/sections/_signify.lua" src lua
***** Tables
Just contains all the icons and modes I use throughout the statusline
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/tables/_icons.lua" src lua
#+include: "./configs/nyoom.nvim/lua/ext/statusline.nvim/lua/tables/_modes.lua" src lua

* Extra :ATTACH:
** Wallpapers
:PROPERTIES:
:ID:       86261973-40ab-49f5-b78b-89514c2f6d9c
:END:
Wallpapers are in =./extra/wallpapers/=
Some of my favorites:
 *Note*: fix later, using links from github
 *TODO*: Attach from github
